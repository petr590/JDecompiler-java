Добавлены `extends` и `implements` в объявление класса (почему я не скопировал это из кода C++?)

Исправлена ошибка с инструкцией anewarray
Исправлена ошибка с приведением массива к java.lang.Объект

Теперь вместо int используется объект класса Modifiers, это гораздо удобнее
(P.S. после этого рефакторинга появилась пара багов, которые я позже исправил)

Исправлена ошибка с вызовом конструктора `this`

Добавлена автоматическая упаковка для классов-оболочек

Исправлена ошибка с именами переменных. Было: x1, x2, x1, x3, x1, x4. Стало: х1, х2, х3, х4, х5, х6.

Исправлена ошибка при чтении атрибута Exceptions

Исправлена ошибка при декомпиляции класса java.lang.Object (его суперкласс равен null)

Исправлена ошибка при написании метода с аргументами без атрибута Code.
Ранее возвращался пустой MethodScope, если длина кода равна 0.
Теперь пустой MethodScope возвращается только тогда, когда длина кода и количество переменных равны 0.

Добавлен класс UncertainReferenceType. Работает аналогично VariableCapacityIntegralType, но для ссылочных типов.

Версия программы установлена как 0.6 (я всегда забывал ее обновить). С этого коммита все версии будут обновлены, если я не забуду.

Класс VariableCapacityIntegralType переименован в UncertainIntegralType


Исправлены методы AnyObjectType.reversedCastToNarrowestImpl и AnyObjectType.reversedCastToWidestImpl.
Ранее они делегировали выполнение методам castToNarrowestImpl и castToWidestImpl (это работало до добавления UncertainReferenceType)

Добавлена загрузка супертипов для Classstype через Class.forName(имя). Это необходимо при декомпиляции кода
, использующего стандартную библиотеку Java (список, карту и т.д.). Хотя какой код ее не использует?


Исправлена декомпиляция такого кода:

if(condition1) {
	// Здесь if указывает не на конец первого if, а на начало code3
	if(condition2) {
		code1;
	}
} else {
	code2;
}
code3;

P.S. Логика системы ссылочных типов (класс UncertainReferenceType) оказалась намного сложнее,
чем я думал, поэтому теперь я собираюсь разобраться с if, else, for, while, try, catch и т.д.

Интересная вещь: выражение вида `y = !!x;` декомпилируется таким же образом, хотя я и не прописывал такого условия.
